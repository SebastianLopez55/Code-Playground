"""

QUESTION:

Cluster Points by Distance

Let cluster((x,y)) denote the cluster containing the point (x,y). Given a list of points
[(x1, y1), (x2, y2), ...]
and a distance d, find the set of clusters generated by the rule
if distance((x,y), (w,z)) < d, then cluster((x,y)) = cluster((w,z)).

In other words, if two points are within a distance d, then they must be in the same cluster.

Note: the points consist of two floating points numbers that can be either positive or negative.

Note: Clusters C can also be defined by the contrapositive definition
C = {(x,y) | distance((x,y), (w,z)) > d for all (w,z) not in C}

Return a list of list where list[i] represents all the points that make part of the ith cluster.

Example:

    INPUT -> [(x_1, y_1), (x_2, y_2), (x_3, y_3), (x_4, y_4)], d = 4
    OUTPUT -> [[(x_1, y_1), (x_2, y_2), (x_3, y_3)], [(x_4, y_4)]]


"""

import math
from collections import defaultdict


def distance(point1, point2):
    """
    Calculate the Euclidean distance between two points.
    """
    (x1, y1), (x2, y2) = point1, point2
    return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)


def make_graph(points, d):
    """
    Create an adjacency list as a graph representation from the given points
    using a dict given the list of points.
    """
    graph = dict()

    # Initialize graph structure.
    for point in points:
        graph[point] = []

    # Populate graphs structure with the given parameters.
    for point1 in points:
        for point2 in points:
            if point1 != point2 and distance(point1, point2) < d:
                graph[point1].append(point2)

    return graph


def helper_bfs(graph, start, visited):
    """
    Perform BFS on the graph from the start point, marking all connected points as visited.
    """
    queue = [start]
    component = set()
    while queue:
        current = queue.pop(0)
        if current not in visited:
            visited.add(current)
            component.add(current)
            # Enqueue all unvisited neighbors
            for neighbor in graph[current]:
                if neighbor not in visited:
                    queue.append(neighbor)  # Add neighbor to the queue if not visited
    return list(component)


def bfs(graph):
    """
    Iterate over the graph, using BFS to find all connected components (clusters).
    """

    visited = set()
    clusters = []
    for node in graph:
        if node not in visited:
            component = helper_bfs(graph, node, visited)
            clusters.append(component)
    return clusters


def cluster_points(points, d):
    """
    Given a list of points and a distance threshold d, find the set of clusters
    generated by the rule: if distance((x, y), (w, z)) < d, then cluster((x, y)) = cluster((w, z)).

    This function first creates a graph based on the distance threshold, then uses
    BFS to find connected components which represent the clusters.
    """
    graph = make_graph(points, d)
    return bfs(graph)


# Example usage:
example_points = [
    (0.0, 1.0),
    (1.0, 0.0),
    (4.0, 4.0),
    (-1.0, -1.0),
    (-1.0, 0.5),
    (10.0, 10.0),
]
distance_threshold = 1.5

# Get the clusters
clusters = cluster_points(example_points, distance_threshold)


for i, cluster in enumerate(clusters, start=1):
    print("\n", f"Cluster {i}:", cluster, "\n")

# Time complexity is dominated by make_graph() which give a O(n^2) time
